<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <!--
    The ESRI Wayback imagery is pretty complex with multiple tiled services being offered (88 of them as at 23/12/2020). Each tiled service has an associated metadata layer that can be queried to retrieve the date and other metadata for the actual image at a specific location. There may be duplicate images in consecutive tiled services.
    testUrl: /restor/wayback/index.html?lng=-69.444&lat=-12.834&zoom=17
  -->
    <title>ESRI Wayback Demo</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.17/esri/themes/light/main.css" />

    <style>
        html,
        body,
        #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        .esri-layer-list {
            width: 310px;
        }
    </style>

    <script src="https://js.arcgis.com/4.17/"></script>

    <script>
        /*global fetch*/
        /*global URL*/
        var map, imageMetadataDiv;

        function lng2Col(lng, zoom) {
            return Math.floor(((lng + 180) / 360) * Math.pow(2, zoom));
        }

        function lat2Row(lat, zoom) {
            return Math.floor(
                ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
                Math.pow(2, zoom),
            );
        }

        function col2Lng(x, z) {
            return (x / Math.pow(2, z)) * 360 - 180;
        }

        function row2lat(y, z) {
            const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
            return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
        }

        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/WebTileLayer",
            "esri/widgets/LayerList",
            "esri/core/promiseUtils",
            "esri/request",
            "esri/core/watchUtils",
            "esri/geometry/support/webMercatorUtils"
        ], function(Map, MapView, WebTileLayer, LayerList, promiseUtils, esriRequest, watchUtils, webMercatorUtils) {
            //flag to set whether the time series shows wayback versions where the central image changes or where any image in the row/col tile changes (less restrictive)
            const useCentreImageForChanges = true;
            //get the lat/long from the query parameters
            var url = new URL(document.URL);
            var search_params = url.searchParams;
            const lat = (search_params.has('lat')) ? Number(search_params.get('lat')) : 0;
            const lng = (search_params.has('lng')) ? Number(search_params.get('lng')) : 0;
            let zoom = (search_params.has('zoom')) ? Number(search_params.get('zoom')) : 17;
            //instantiate a new map
            map = new Map({
                basemap: "streets",
            });
            //create a map view centred on the lat/long
            const view = new MapView({
                container: "viewDiv",
                map: map,
                zoom: zoom,
                center: [lng, lat], //restoration site lng=-69.4447580957905&lat=-12.8342947940155
            });
            //focus the view
            view.focus();
            //get the col/rows for this lat/long
            let row = lat2Row(view.center.y, zoom);
            let col = lng2Col(view.center.x, zoom);
            //load the wayback configuration - this contains the specifications for all of the tiled layers
            fetch("https://s3-us-west-2.amazonaws.com/config.maptiles.arcgis.com/waybackconfig.json").then(async function(response) {
                const config = await response.json();
                let versions = [];
                //add a date to each of the versions
                for (const version in config) {
                    const [year, month, day] = config[version].itemTitle.substr(config[version].itemTitle.length - 11, 10).split("-");
                    //add a date for the version so we can sort on date
                    versions.push(Object.assign(config[version], { version_date: new Date(year, month - 1, day), version_number: Number(version) }));
                }
                //sort by date
                versions.sort(function(a, b) {
                    return a.version_date - b.version_date;
                });
                //initialise the set of release versions that have local changes
                let version_numbers_with_local_changes = new Set();
                //we must iterate through the versions to build up a list of the versions that have local changes - start by getting the latest version number
                let version_position = versions.length;
                let local_changes, version_number;
                do {
                    //now get the version number
                    version_number = versions[version_position - 1].version_number;
                    //get the tilemap request
                    url = "https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tilemap/" + version_number + "/" + zoom + "/" + row + "/" + col;
                    response = await esriRequest(url);
                    //see if this version has local changes
                    local_changes = (response.data.data[0]);
                    //get the version number with local changes
                    if (local_changes) {
                        version_number = (response.data.hasOwnProperty('select')) ? response.data.select[0] : version_number;
                        //add this version number to the local changes version set
                        version_numbers_with_local_changes.add(version_number);
                        //get the position of this release in the version_numbers array
                        version_position = versions.findIndex(item => (item.version_number === version_number));
                    }
                    else { //no more local changes
                        version_position = 0;
                    }
                }
                while (version_position !== 0);
                //now we have the version numbers of the versions that have local changes - filter the versions using these numbers
                versions = versions.filter(item => (version_numbers_with_local_changes.has(item.version_number)));
                //get the images at the centre of these versions
                versions = await getCentreImages(versions);
                //initialise the timeslice
                let timeslice = 0;
                //add the individual WMTS layers
                versions.map((item, index) => {
                    map.layers.push(new WebTileLayer({
                        urlTemplate: item.itemURL,
                        id: item.itemID,
                        copyright: "ESRI Imagery",
                        opacity: 0
                    }));
                });
                //poll to see when the map has finished loading all its tiles
                this.interval = setInterval(function() {
                    //see if the tiles have finished loading
                    if (!view.updating) {
                        clearInterval(this.interval);
                        map.layers.items.map((layer, index) => {
                            layer.opacity = (index === 0) ? 1 : 0;
                        });
                        console.log("ready");
                    }
                }, 1000);
                //add the date div
                imageMetadataDiv = document.createElement("div");
                imageMetadataDiv.id = "imageMetadataDiv";
                imageMetadataDiv.className = "esri-widget esri-component";
                imageMetadataDiv.style.padding = "7px 15px 5px";
                imageMetadataDiv.style.textAlign = "center";
                view.ui.add(imageMetadataDiv, "top-right");
                //set the initial timeslice
                setUITimeslice(versions, 0);
                //stop the map moving on keyboard events - this should only change the timeslice
                view.on("key-down", function(event) {
                    event.stopPropagation();
                });
                //get changes to the centre when the view is stationary
                watchUtils.whenTrue(view, "stationary", function() {
                    const latLng = webMercatorUtils.xyToLngLat(view.center.x, view.center.y);
                    var newurl = window.location.protocol + "//" + window.location.host + window.location.pathname + "?lng=" + latLng[0] + "&lat=" + latLng[1] + "&zoom=" + view.zoom;
                    window.history.pushState({ path: newurl }, '', newurl);
                });
                //wire up key down event
                document.addEventListener('keydown', function(event) {
                    var prohibitedKeys = ["ArrowRight", "ArrowLeft"];
                    var keyPressed = event.key;
                    if (prohibitedKeys.indexOf(keyPressed) !== -1) {
                        //stop the map navigation
                        event.stopPropagation();
                        //increment/decrement the timeslice
                        let step = (keyPressed === "ArrowRight") ? 1 : -1;
                        timeslice = (timeslice === 0) ? (step === 1) ? 1 : versions.length - 1 : (timeslice + step) % versions.length;
                        //update the ui
                        setUITimeslice(versions, timeslice);
                    }
                });
            });

            //updates the UI for a specific timeslice by setting the imageMetadataDiv inner html and the visibility of the map layer
            function setUITimeslice(versions, timeslice) {
                //set the date
                imageMetadataDiv.innerHTML = setImageDivHTML(versions, timeslice);
                //get the timeslice layer and make it visible
                map.layers.items.map((layer, index) => {
                    if (!view.updating) layer.opacity = (index === timeslice) ? 1 : 0;
                });
            }

            function getCentreImages(versions) {
                return new Promise(resolve => {
                    //get the dates of the imagery for the centre of the map
                    versions = versions.map(version => {
                        let retValue = {};
                        Object.assign(retValue, version, { centreImage: { metadataUrl: version.metadataLayerUrl + "/6/query/query?f=json&where=1%3D1&outFields=SRC_DATE2%2CNICE_DESC%2CSRC_DESC%2CSRC_RES%2CSRC_ACC&geometry=%7B%22spatialReference%22%3A%7B%22latestWkid%22%3A4326%7D%2C%22x%22%3A" + lng + "%2C%22y%22%3A" + lat + "%7D&geometryType=esriGeometryPoint&spatialRel=esriSpatialRelIntersects&returnGeometry=false" } });
                        return retValue;
                    });
                    //make the requests
                    var promises = versions.map(version => esriRequest(version.centreImage.metadataUrl));
                    //wait until all requests have resolved 
                    promiseUtils.eachAlways(promises).then(results => {
                        //iterate through the results and get the individual image metadata
                        results.map(resolved => {
                            if (resolved.value.data.hasOwnProperty('features') && resolved.value.data.features.length) {
                                //get the image as a feature
                                const image = resolved.value.data.features[0];
                                //get the metadata
                                const metadata = (image.hasOwnProperty('attributes')) ? image.attributes : {};
                                //add the date in human readable form
                                Object.assign(metadata, metadata, { image_date: new Date(metadata.SRC_DATE2) });
                                //merge the image metadata onto the tiled service version metadata
                                let version = versions.filter(_v => (_v.centreImage.metadataUrl === resolved.value.url))[0];
                                //merge the image metadata
                                Object.assign(version.centreImage, version.centreImage, metadata);
                            }
                        });
                        if (useCentreImageForChanges) {
                            //initialise a new set to hold the unique image dates
                            let unique_image_dates = new Set();
                            //filter the versions for the latest versions with the image date - the later dates have better contrast for the same image
                            versions = versions.slice(0).reverse().map(version => {
                                const retValue = (unique_image_dates.has(version.centreImage.SRC_DATE2)) ? undefined : version;
                                //add the date to the unique date set
                                unique_image_dates.add(version.centreImage.SRC_DATE2);
                                return retValue;
                            });
                            //reverse the order again to be chronological again
                            versions = versions.slice(0).reverse();
                        }
                        //remove the undefined elements and those which dont have image metadata
                        versions = versions.filter(item => ((item !== undefined) && (item.centreImage.hasOwnProperty("image_date"))));
                        //return a value
                        resolve(versions);
                    });
                });
            }

            //gets the image div html from the image metadata
            function setImageDivHTML(versions, index) {
                let sensor = "";
                const img = versions[index].centreImage;
                const image_date = (img.hasOwnProperty("image_date")) ? img.image_date.toLocaleString().substr(0, 10) : "";
                switch (img.SRC_DESC) {
                    case 'GE01':
                        sensor = "GeoEye1";
                        break;
                    case 'WV01':
                        sensor = "WorldView1";
                        break;
                    case 'WV02':
                        sensor = "WorldView2";
                        break;
                    case 'WV03':
                        sensor = "WorldView3";
                        break;
                    case 'WV04':
                        sensor = "WorldView4";
                        break;
                    default:
                        sensor = img.SRC_DESC;
                }
                return img.NICE_DESC + " " + sensor + " (" + img.SRC_RES + "m)&nbsp;&nbsp;&nbsp;&nbsp;" + image_date + "<br>" + Number(index + 1) + " of " + versions.length + " images";
            }
        });
    </script>
</head>

<body>
    <div id="viewDiv"></div>
</body>

</html>
