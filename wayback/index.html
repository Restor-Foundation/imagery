<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <!--
    The ESRI Wayback imagery is pretty complex with multiple tiled services being offered (88 of them as at 23/12/2020). Each tiled service has an associated metadata layer that can be queried to retrieve the date and other metadata for the actual image at a specific location. There may be duplicate images in consecutive tiled services.
    testUrl: /wayback/index.html?siteid=507
  -->
    <title>Restor High Resolution Monitoring</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.18/esri/themes/dark/main.css" />

    <style>
        html,
        body,
        #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        #loading {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            background-color: black;
            text-align: center;
            display: flex;
            justify-content: center;
        }

        #loadingContainer {
            width: 70px;
            height: 70px;
            position: absolute;
            top: 50%;
            -ms-transform: translateY(-50%);
            transform: translateY(-50%);
        }

        #loadingImg {
            height: 36px;
            margin-bottom: 5px;
        }

        #loadingText {
            font-size: 12px;
            color: rgb(190, 193, 200);
            font-family: "Fira Sans Condensed", sans-serif;
            margin-left: 9px;
            margin-top: 2px;
        }

        .esri-icon-reverse {
            background-color: black;
        }

        .esri-icon-forward {
            background-color: black;
        }

        .esri-icon-play {
            background-color: black;
        }

        .esri-widget--button {
            background-color: black !important;
        }

        .esri-time-slider__animation {
            margin: 7px;
        }

        .esri-time-slider__layout--compact .esri-time-slider__row:nth-child(2) {
            height: inherit !important;
        }

        .esri-time-slider__slider {
            height: 60px !important;
            /*border-bottom: 1px solid rgb(54, 58, 64) !important;*/
        }

        .esri-time-slider__row {
            padding: 0px !important;
            background-color: black;
        }

        .esri-time-slider__time-extent {
            display: none !important;
        }

        .esri-layer-list {
            width: 310px;
        }

        .esri-ui-corner-container {
            inset: 15px 0px 15px !important;
        }

        .esri-slider__content {
            margin-bottom: 35px !important;
        }

        .esri-slider__track {
            top: 34px !important;
            height: 0px !important;
        }

        .esri-time-slider__slider {
            background-color: black !important;
        }

        .esri-time-slider__slider .esri-slider {
            background-color: black !important;
        }

        .esri-slider__ticks {
            /*border-bottom: 1px solid rgb(54, 58, 64) !important;*/
        }

        .yearTics {
            top: 1px !important;
            height: 36px !important;
            background-color: rgb(54, 58, 64) !important;
        }

        .yearLabels {
            top: -30px !important;
            font-size: 8px !important;
        }

        .timesliceTics {
            width: 2px !important;
            height: 14px !important;
            color: rgb(245, 247, 250);
            top: 11px !important;
        }

        .timesliceTicsActive {
            width: 2px !important;
            background: rgb(255, 222, 102) !important;
            height: 14px !important;
            top: 11px !important;
        }

        .esri-slider__thumb {
            margin-left: 7px !important;
            border-width: 0px !important;
            margin-top: -5px !important;
            width: 4px !important;
            background: rgb(255, 222, 102) !important;
            border-radius: 3px !important;
            height: 24px !important;
            cursor: ew-resize !important;
        }

        .esri-slider__thumb:hover {
            transform: scale(1);
        }

        .esri-slider__anchor:focus .esri-slider__thumb,
        .esri-slider__anchor:focus .esri-slider__label {
            outline: none;
        }
    </style>

    <script src="https://js.arcgis.com/4.18/"></script>

    <script>
        /*global fetch*/
        const LOCAL_CHANGES_ZOOM = 17;
        const SITES_API_ENDPOINT = "https://api-dot-restor-eco-production.oa.r.appspot.com/api/sites/";
        const WAYBACK_CONFIG_ENDPOINT = "https://s3-us-west-2.amazonaws.com/config.maptiles.arcgis.com/waybackconfig.json";
        const WAYBACK_TILEMAP_ENDPOINT = "https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tilemap/";
        var map, timeslider, geometry;

        function lng2Col(lng, zoom) {
            return Math.floor(((lng + 180) / 360) * Math.pow(2, zoom));
        }

        function lat2Row(lat, zoom) {
            return Math.floor(
                ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
                Math.pow(2, zoom),
            );
        }

        function getSiteGeometryLayer(siteid, Polygon, Graphic, SimpleFillSymbol, GraphicsLayer) {
            return new Promise(async resolve => {
                //get the sites geometry
                const response = await fetch(SITES_API_ENDPOINT + siteid);
                if (response.status === 404) alert("Site not found");
                const json = await response.json();
                //get the geometry
                geometry = json.geometry;
                //create a polygon
                const polygon = new Polygon({ rings: geometry.coordinates });
                //add it to the map
                var graphic = new Graphic({ // graphic with polygon geometry
                    geometry: polygon,
                    symbol: new SimpleFillSymbol({
                        style: "none",
                        color: "none",
                        outline: {
                            color: [220, 220, 220, 1],
                            width: "2px"
                        }
                    })
                });
                var layer = new GraphicsLayer({
                    graphics: [graphic]
                });
                //return the layer as a promise
                resolve(layer);
            });
        }

        function getWaybackVersions() {
            return new Promise(async resolve => {
                //load the wayback configuration - this contains the specifications for all of the tiled layers
                const response = await fetch(WAYBACK_CONFIG_ENDPOINT);
                const config = await response.json();
                let versions = [];
                //add a date to each of the versions
                for (const version in config) {
                    const [year, month, day] = config[version].itemTitle.substr(config[version].itemTitle.length - 11, 10).split("-");
                    //add a date for the version so we can sort on date
                    versions.push(Object.assign(config[version], { version_date: new Date(year, month - 1, day), version_number: Number(version) }));
                }
                //sort by date
                versions.sort(function(a, b) {
                    return a.version_date - b.version_date;
                });
                resolve(versions);
            });
        }

        function getWaybackLayers(view, siteExtent, esriRequest, WebTileLayer, promiseUtils) {
            return new Promise(async resolve => {
                //load the wayback configuration - this contains the specifications for all of the tiled layers
                let versions = await getWaybackVersions();
                //initialise the set of versions that have local changes
                let version_numbers_with_local_changes = new Set();
                //we must iterate through the versions to build up a list of the versions that have local changes - start by getting the latest version number
                let version_position = versions.length;
                let local_changes, version_number, url, response;
                //get the site center lat/lng
                const lng = siteExtent.center.longitude;
                const lat = siteExtent.center.latitude;
                //get the col/rows for this lat/long
                let row = lat2Row(lat, LOCAL_CHANGES_ZOOM);
                let col = lng2Col(lng, LOCAL_CHANGES_ZOOM);
                do {
                    //now get the version number
                    version_number = versions[version_position - 1].version_number;
                    //get the tilemap request
                    url = WAYBACK_TILEMAP_ENDPOINT + version_number + "/" + LOCAL_CHANGES_ZOOM + "/" + row + "/" + col;
                    response = await esriRequest(url);
                    //see if this version has local changes
                    local_changes = (response.data.data[0]);
                    //get the version number with local changes
                    if (local_changes) {
                        version_number = (response.data.hasOwnProperty('select')) ? response.data.select[0] : version_number;
                        //add this version number to the local changes version set
                        version_numbers_with_local_changes.add(version_number);
                        //get the position of this version in the version_numbers array
                        version_position = versions.findIndex(item => (item.version_number === version_number));
                    }
                    else { //no more local changes
                        version_position = 0;
                    }
                }
                while (version_position !== 0);
                //now we have the version numbers of the versions that have local changes - filter the versions using these numbers
                let localVersions = versions.filter(item => (version_numbers_with_local_changes.has(item.version_number)));
                //get the image metadata for the images at the centre of these versions (and add it to the localVersions)
                localVersions = await getCentreImageMetadata(localVersions, lng, lat, promiseUtils, esriRequest);
                //add the individual WMTS layers
                const waybackLayers = localVersions.map(item => {
                    return new WebTileLayer({
                        urlTemplate: item.itemURL,
                        id: item.itemID,
                        copyright: "ESRI Imagery",
                        opacity: 0,
                        date: item.centreImage.image_date
                    });
                });
                //return a value
                resolve(waybackLayers);
            });
        }

        async function getCentreImageMetadata(localVersions, lng, lat, promiseUtils, esriRequest) {
            return new Promise(async resolve => {
                //get the dates of the imagery for the centre of the map
                localVersions = localVersions.map(version => {
                    let retValue = {};
                    Object.assign(retValue, version, { centreImage: { metadataUrl: version.metadataLayerUrl + "/6/query/query?f=json&where=1%3D1&outFields=SRC_DATE2%2CNICE_DESC%2CSRC_DESC%2CSRC_RES%2CSRC_ACC&geometry=%7B%22spatialReference%22%3A%7B%22latestWkid%22%3A4326%7D%2C%22x%22%3A" + lng + "%2C%22y%22%3A" + lat + "%7D&geometryType=esriGeometryPoint&spatialRel=esriSpatialRelIntersects&returnGeometry=false" } });
                    return retValue;
                });
                //make the requests
                var promises = localVersions.map(version => esriRequest(version.centreImage.metadataUrl));
                //wait until all requests have resolved 
                const results = await promiseUtils.eachAlways(promises);
                //iterate through the results and get the individual image metadata
                let version, image, metadata;
                results.map(resolved => {
                    if (resolved.value.data.hasOwnProperty('features') && resolved.value.data.features.length) {
                        //get the image as a feature
                        image = resolved.value.data.features[0];
                        //get the metadata
                        metadata = (image.hasOwnProperty('attributes')) ? image.attributes : {};
                        //add the date in human readable form
                        Object.assign(metadata, metadata, { image_date: new Date(metadata.SRC_DATE2) });
                        //merge the image metadata onto the tiled service version metadata
                        version = localVersions.filter(_v => (_v.centreImage.metadataUrl === resolved.value.url))[0];
                        //merge the image metadata
                        Object.assign(version.centreImage, version.centreImage, metadata);
                    }
                });
                //initialise a new set to hold the unique image dates
                let unique_image_dates = new Set();
                //filter the localVersions for the latest versions with the image date - the later dates have better contrast for the same image
                localVersions = localVersions.slice(0).reverse().map(version => {
                    const retValue = (unique_image_dates.has(version.centreImage.SRC_DATE2)) ? undefined : version;
                    //add the date to the unique date set
                    unique_image_dates.add(version.centreImage.SRC_DATE2);
                    return retValue;
                });
                //reverse the order again to be chronological again
                localVersions = localVersions.slice(0).reverse();
                //remove the undefined elements and those which dont have image metadata
                localVersions = localVersions.filter(item => ((item !== undefined) && (item.centreImage.hasOwnProperty("image_date"))));
                //return a value
                resolve(localVersions);
            });
        }

        function createTimeSlider(map, view, TimeSlider, TimeExtent) {
            //get the wayback dates
            let waybackDates = map.layers.map(layer => {
                if (layer.type === "web-tile") {
                    return new Date(layer.date);
                }
            }).items;
            //filter out the nulls
            waybackDates = waybackDates.filter(item => { return (item !== undefined); });
            //get the year dates for the year tic marks
            const numYears = new Date().getFullYear() - waybackDates[0].getFullYear();
            const years = Array.from({ length: numYears + 1 }, (x, i) => i + waybackDates[0].getFullYear());
            const yearTics = years.map(year => {
                return new Date(year, 0, 1);
            });
            //set the time extent
            const timeExtent = new TimeExtent({
                start: new Date(waybackDates[0].getFullYear(), 0, 1),
                end: new Date()
            });
            const timesliderContainer = document.createElement("div");
            timesliderContainer.id = "timeslider";
            timeslider = new TimeSlider({
                view: view,
                container: timesliderContainer,
                mode: "instant",
                loop: true,
                timeVisible: false,
                fullTimeExtent: timeExtent,
                stops: { dates: waybackDates },
                labelFormatFunction: (value, type, element, layout) => {
                    switch (type) {
                        case "min":
                        case "max":
                            element.setAttribute("style", "display: 'none'");
                            break;
                    }
                },
                tickConfigs: [{
                    mode: "position",
                    values: waybackDates,
                    tickCreatedFunction: function(initialValue, tickElement, labelElement) {
                        tickElement.classList.add("timesliceTics");
                    }
                }, {
                    mode: "position",
                    values: yearTics,
                    labelsVisible: true,
                    labelFormatFunction: (value) => {
                        return value.getFullYear();
                    },
                    tickCreatedFunction: function(initialValue, tickElement, labelElement) {
                        tickElement.classList.add("yearTics");
                        labelElement.classList.add("yearLabels");
                    }
                }, {
                    mode: "position",
                    values: waybackDates[0],
                    tickCreatedFunction: function(initialValue, tickElement, labelElement) {
                        tickElement.classList.add("timesliceTicsActive");
                    }
                }]
            });
            // Add the widget to the bottom-right corner of the view
            view.ui.add(timeslider, {
                position: "bottom-right"
            });
            //watch for events on the time slider
            timeslider.watch("timeExtent", (value) => {
                //get the timeslice date 
                const timeslice = new Date(value.start).getTime();
                //set the active tic 
                timeslider.tickConfigs[2].values = [value.start];
                //update the layers visibility
                map.layers.items.forEach(layer => {
                    //only update the opacity of web tile layers
                    if (layer.type === "web-tile") layer.opacity = (layer.date.getTime() === timeslice) ? 1 : 0;
                });
            });
        }

        require([
            "esri/Map", "esri/views/MapView", "esri/layers/WebTileLayer", "esri/widgets/LayerList", "esri/core/promiseUtils", "esri/request", "esri/core/watchUtils", "esri/geometry/support/webMercatorUtils", "esri/widgets/TimeSlider", "esri/TimeExtent", "esri/layers/GraphicsLayer", "esri/Graphic", "esri/symbols/SimpleFillSymbol", "esri/geometry/Polygon", "dojo/dom-style"
        ], function(Map, MapView, WebTileLayer, LayerList, promiseUtils, esriRequest, watchUtils, webMercatorUtils, TimeSlider, TimeExtent, GraphicsLayer, Graphic, SimpleFillSymbol, Polygon, domStyle) {
            //get the lat/long from the query parameters
            var url = new URL(document.URL);
            var search_params = url.searchParams;
            const siteid = (search_params.has('siteid')) ? Number(search_params.get('siteid')) : 507; //zurich
            //instantiate a new map
            map = new Map({
                basemap: "streets",
            });
            //create a map view centred on the lat/long
            const view = new MapView({
                container: "viewDiv",
                map: map
            });
            //get the site layer which also gets the sites geometry
            getSiteGeometryLayer(siteid, Polygon, Graphic, SimpleFillSymbol, GraphicsLayer).then(async siteLayer => {
                //get the site extent
                const siteExtent = siteLayer.graphics.items[0].geometry.extent;
                //get the wayback layers
                const waybackLayers = getWaybackLayers(view, siteExtent, esriRequest, WebTileLayer, promiseUtils);
                //build a list of promises for 1) the view to finish loading, 2) the Wayback layers to load 
                const promises = [view.when(), waybackLayers];
                //wait for the promises to resolve
                const results = await promiseUtils.eachAlways(promises);
                //zoom the map to the extent of the site 
                view.goTo(siteExtent);
                //get the wayback layers
                const waybackLyrs = results[1].value;
                //add the wayback layers
                waybackLyrs.forEach(layer => {
                    map.add(layer);
                });
                //add the site layer
                map.add(siteLayer);
                //poll to see when the map has finished loading all its tiles
                this.interval = setInterval(function() {
                    //see if the tiles have finished loading
                    if (!view.updating) {
                        clearInterval(this.interval);
                        //create the timeslider
                        createTimeSlider(map, view, TimeSlider, TimeExtent);
                        //show the map
                        domStyle.set("loading", "display", "none");
                    }
                }, 1000);
                //stop the map moving on keyboard events - this should only change the timeslice
                view.on("key-down", function(event) {
                    event.stopPropagation();
                });
                //wire up key down event
                document.addEventListener('keydown', function(event) {
                    var allowedKeys = ["ArrowRight", "ArrowLeft"];
                    if (allowedKeys.indexOf(event.key) !== -1) {
                        //stop the map navigation
                        event.stopPropagation();
                        //increment/decrement the timeslice
                        if (event.key === "ArrowRight") {
                            timeslider.next();
                        }
                        else {
                            timeslider.previous();
                        }
                    }
                });
            });
        });
    </script>
</head>

<body>
    <div id="loading">
        <div id="loadingContainer"><img src="loading.gif" id="loadingImg">
            <div id="loadingText">LOADING...</div>
        </div>
    </div>
    <div id="viewDiv"></div>
</body>

</html>
